/**
 * EDA BOM Converter Web App (Mouser + Digi-Key)
 * - Upload & Preview
 * - Header row selection (frontend)
 * - Column mapping:
 *    - If mapping.mpnColIndex / mapping.qtyColIndex provided => use them (dropdown override)
 *    - Else => auto-detect from header row text (fallback)
 * - Data start row:
 *    - If mapping.dataStartRowIndex provided => use it
 *    - Else => auto-adjust scanning downward to first row that has MPN or QTY (skip blank rows)
 *
 * Digi-Key output requirement:
 *  - Row 1 blank
 *  - Header on Row 2
 *  - Column A header: "Manufacturer Product Number"
 *  - Column B header: "Quantity"
 *
 * Export fix:
 * - SpreadsheetApp.flush() + Utilities.sleep() before Drive export
 *
 * Requirements:
 * - Advanced Drive Service v3 enabled (Drive.Files.copy)
 * - OAuth scopes: drive, spreadsheets, script.external_request
 */

function doGet() {
  return HtmlService.createHtmlOutputFromFile("Index")
    .setTitle("EDA BOM Converter (Mouser / Digi-Key)")
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

const MAX_BYTES = 8 * 1024 * 1024; // 8MB

// Mouser template headers
const MOUSER_HEADERS = [
  "Mfr Part Number (Input)",
  "Manufacturer Part Number",
  "Mouser Part Number",
  "Manufacturer Name",
  "Description",
  "Quantity 1",
  "Unit Price 1",
  "Quantity 2",
  "Unit Price 2",
  "Quantity 3",
  "Unit Price 3",
  "Quantity 4",
  "Unit Price 4",
  "Quantity 5",
  "Unit Price 5",
  "Order Quantity",
  "Order Unit Price",
  "Min./Mult.",
  "Availability",
  "Lead Time in Days",
  "Lifecycle",
  "NCNR",
  "RoHS",
  "Pb Free",
  "Package Type",
  "Datasheet URL",
  "Product Image",
  "Design Risk"
];

// Digi-Key headers (MUST match exactly)
const DIGIKEY_HEADERS = ["Manufacturer Product Number", "Quantity"];

/**
 * Upload file as base64 dataURL, store temporarily, convert to Google Sheets,
 * return a preview matrix to the frontend.
 */
function uploadAndGetPreview(payload) {
  try {
    if (!payload || !payload.dataUrl) return { ok: false, error: "No file data received." };

    const filename = String(payload.filename || "uploaded_file");
    const mimeType = String(payload.mimeType || "application/octet-stream");
    const dataUrl = String(payload.dataUrl);

    const commaIndex = dataUrl.indexOf(",");
    if (commaIndex < 0) return { ok: false, error: "Invalid dataUrl format (missing comma)." };

    const header = dataUrl.slice(0, commaIndex);
    const base64 = dataUrl.slice(commaIndex + 1);
    if (!header.includes(";base64")) return { ok: false, error: "Invalid dataUrl header (missing ;base64)." };

    const bytes = Utilities.base64Decode(base64);
    const sizeBytes = bytes.length;
    if (sizeBytes > MAX_BYTES) {
      return { ok: false, error: `File too large: ${sizeBytes} bytes (limit: ${MAX_BYTES} bytes).` };
    }

    // 1) Save original file temporarily
    const blob = Utilities.newBlob(bytes, mimeType, filename);
    const srcFile = DriveApp.createFile(blob);

    // 2) Convert to Google Sheets (Advanced Drive Service v3)
    const converted = Drive.Files.copy(
      { title: filename, mimeType: MimeType.GOOGLE_SHEETS },
      srcFile.getId()
    );
    const sheetId = converted.id;

    // 3) Read preview
    const ss = SpreadsheetApp.openById(sheetId);
    const sh = ss.getSheets()[0];

    const lastRow = sh.getLastRow();
    const lastCol = sh.getLastColumn();
    if (lastRow < 1 || lastCol < 1) {
      return { ok: false, error: "No data detected in the sheet.", token: { srcFileId: srcFile.getId(), sheetId } };
    }

    const PREVIEW_ROWS = Math.min(120, lastRow);
    const PREVIEW_COLS = Math.min(40, lastCol);
    const values = sh.getRange(1, 1, PREVIEW_ROWS, PREVIEW_COLS).getValues();

    return {
      ok: true,
      token: { srcFileId: srcFile.getId(), sheetId },
      preview: { values, rowCount: PREVIEW_ROWS, colCount: PREVIEW_COLS },
      serverTime: new Date().toISOString()
    };
  } catch (err) {
    return { ok: false, error: String(err) };
  }
}

/**
 * Export Google Sheets file as XLSX Blob via Drive API v3 export endpoint.
 */
function exportGoogleFileAsXlsxBlob_(fileId, filenameForBlob) {
  const exportMime = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
  const url =
    "https://www.googleapis.com/drive/v3/files/" +
    encodeURIComponent(fileId) +
    "/export?mimeType=" +
    encodeURIComponent(exportMime);

  const params = {
    method: "get",
    headers: { Authorization: "Bearer " + ScriptApp.getOAuthToken() },
    muteHttpExceptions: true
  };

  const res = UrlFetchApp.fetch(url, params);
  const code = res.getResponseCode();

  if (code !== 200) {
    return { ok: false, error: "Drive export failed. HTTP " + code + " / " + res.getContentText() };
  }

  const blob = res.getBlob().setName(filenameForBlob || "output.xlsx");
  return { ok: true, blob, mimeType: exportMime };
}

/** ===== Helpers ===== */

function toStr_(v) {
  if (v === null || v === undefined) return "";
  return String(v).trim();
}

function toQty_(v) {
  if (v === null || v === undefined || v === "") return "";
  if (typeof v === "number") return v;
  const s = String(v).trim();
  if (!s) return "";
  const n = Number(s.replace(/,/g, ""));
  if (isFinite(n)) return n;
  return s; // keep original if not numeric
}

/**
 * Auto-detect MPN/QTY columns from header row text.
 * Returns { mpnColIndex, qtyColIndex } or nulls when not found.
 */
function detectColsFromHeaderRow_(headerRow) {
  const cells = (headerRow || []).map(toStr_);
  const lower = cells.map(s => s.toLowerCase());

  const mpnPatterns = [
    /\bmpn\b/,
    /\bmanufacturer\s*part\s*number\b/,
    /\bmfr\s*part\s*number\b/,
    /\bpart\s*number\b/,
    /\bp\/n\b/,
    /\bpn\b/
  ];

  const qtyPatterns = [
    /\bqty\b/,
    /\bquantity\b/,
    /\border\s*qty\b/
  ];

  function findIdx(patterns) {
    for (let i = 0; i < lower.length; i++) {
      const t = lower[i];
      if (!t) continue;
      for (const rx of patterns) {
        if (rx.test(t)) return i;
      }
    }
    return null;
  }

  let mpn = findIdx(mpnPatterns);
  let qty = findIdx(qtyPatterns);

  // soft fallback
  if (mpn === null) {
    for (let i = 0; i < lower.length; i++) {
      if (/\bpart\b/.test(lower[i])) { mpn = i; break; }
    }
  }

  return { mpnColIndex: mpn, qtyColIndex: qty };
}

/**
 * Determine effective data start row index (0-based).
 * - If mapping.dataStartRowIndex provided: use it (validated)
 * - Else: scan from headerRowIndex+1 downward; first row where (mpn OR qty) not blank
 * If none found, returns headerRowIndex+1.
 */
function inferDataStartRowIndex_(values2d, headerRowIndex, mpnColIndex, qtyColIndex) {
  const start = headerRowIndex + 1;
  for (let r = start; r < values2d.length; r++) {
    const mpn = toStr_(values2d[r][mpnColIndex]);
    const qty = toStr_(values2d[r][qtyColIndex]);
    if (mpn === "" && qty === "") continue;
    return r;
  }
  return start;
}

/**
 * Shared: read source rows using mapping
 * mapping:
 * - headerRowIndex (required, 0-based)
 * - mpnColIndex / qtyColIndex (optional, 0-based, dropdown override)
 * - dataStartRowIndex (optional, 0-based)
 * - aggregateSameMpn (optional)
 */
function readMappedRows_(sheetId, mapping) {
  const headerRowIndex = Number(mapping.headerRowIndex);
  if (!isFinite(headerRowIndex) || headerRowIndex < 0) throw new Error("Invalid headerRowIndex");

  const aggregateSameMpn = !!mapping.aggregateSameMpn;

  // Dropdown override (optional)
  const providedMpn = (mapping.mpnColIndex !== undefined && mapping.mpnColIndex !== null) ? Number(mapping.mpnColIndex) : null;
  const providedQty = (mapping.qtyColIndex !== undefined && mapping.qtyColIndex !== null) ? Number(mapping.qtyColIndex) : null;

  // Optional dataStartRowIndex
  const providedDataStart = (mapping.dataStartRowIndex !== undefined && mapping.dataStartRowIndex !== null) ? Number(mapping.dataStartRowIndex) : null;

  const inSS = SpreadsheetApp.openById(String(sheetId));
  const inSh = inSS.getSheets()[0];

  const lastRow = inSh.getLastRow();
  const lastCol = inSh.getLastColumn();
  if (lastRow < 1 || lastCol < 1) throw new Error("No data in source sheet.");

  const headerRow1 = headerRowIndex + 1;
  if (headerRow1 > lastRow) throw new Error("Header row is beyond last row.");

  // Read full preview-like area needed for mapping & scanning
  // We only need up to lastCol and down to lastRow.
  const allValues = inSh.getRange(1, 1, lastRow, lastCol).getValues();

  // Resolve mpn/qty columns
  let mpnColIndex = null;
  let qtyColIndex = null;

  if (providedMpn !== null && isFinite(providedMpn) && providedMpn >= 0) mpnColIndex = providedMpn;
  if (providedQty !== null && isFinite(providedQty) && providedQty >= 0) qtyColIndex = providedQty;

  // If not provided, auto-detect from header row
  if (mpnColIndex === null || qtyColIndex === null) {
    const headerRow = allValues[headerRowIndex] || [];
    const det = detectColsFromHeaderRow_(headerRow);

    if (mpnColIndex === null) mpnColIndex = det.mpnColIndex;
    if (qtyColIndex === null) qtyColIndex = det.qtyColIndex;
  }

  // Still not found -> force user to pick via dropdown
  if (mpnColIndex === null || qtyColIndex === null) {
    throw new Error("Could not detect MPN/QTY columns. Please select them using the dropdown.");
  }

  // Validate column indices within sheet
  if (mpnColIndex + 1 > lastCol || qtyColIndex + 1 > lastCol) {
    throw new Error(`Selected column index exceeds sheet columns. lastCol=${lastCol}`);
  }

  // Data start row index (0-based)
  let dataStartRowIndex = null;
  if (providedDataStart !== null && isFinite(providedDataStart) && providedDataStart >= 0) {
    dataStartRowIndex = providedDataStart;
  } else {
    dataStartRowIndex = inferDataStartRowIndex_(allValues, headerRowIndex, mpnColIndex, qtyColIndex);
  }

  if (dataStartRowIndex + 1 > lastRow) {
    throw new Error("Data start row is beyond last row.");
  }

  const warnings = [];
  const mpnMap = new Map();
  const items = [];

  for (let r = dataStartRowIndex; r < allValues.length; r++) {
    const row = allValues[r];

    const mpn = toStr_(row[mpnColIndex]);
    if (!mpn) continue;

    const qtyVal = toQty_(row[qtyColIndex]);

    if (qtyVal === "") warnings.push(`Row ${r + 1}: quantity blank for MPN "${mpn}"`);
    if (typeof qtyVal === "string" && qtyVal !== "") warnings.push(`Row ${r + 1}: quantity not numeric ("${qtyVal}") for MPN "${mpn}"`);

    if (aggregateSameMpn) {
      const prev = mpnMap.get(mpn);
      if (prev === undefined) {
        mpnMap.set(mpn, qtyVal);
      } else {
        if (typeof prev === "number" && typeof qtyVal === "number") {
          mpnMap.set(mpn, prev + qtyVal);
        } else {
          warnings.push(`MPN "${mpn}" duplicated but quantity is not clean numeric; kept first value.`);
        }
      }
    } else {
      items.push({ mpn, qtyVal });
    }
  }

  if (aggregateSameMpn) {
    for (const [mpn, qtyVal] of mpnMap.entries()) items.push({ mpn, qtyVal });
  }

  if (items.length === 0) {
    // 여기서 빈 결과가 나오면, 대부분 "열 선택/헤더행 선택이 잘못됨" 케이스가 많습니다.
    // 그래서 디버깅 도움을 주기 위해 인덱스 정보를 같이 넣어줍니다.
    throw new Error(
      `No valid rows found. (MPN column had no data after row ${dataStartRowIndex + 1})` +
      ` / headerRow=${headerRowIndex + 1}, mpnCol=${mpnColIndex + 1}, qtyCol=${qtyColIndex + 1}`
    );
  }

  return {
    warnings,
    items,
    resolved: {
      headerRowIndex,
      dataStartRowIndex,
      mpnColIndex,
      qtyColIndex
    }
  };
}

/** ===== Converters ===== */

/**
 * Convert to Mouser template (.xlsx)
 */
function convertToMouserTemplate(req) {
  try {
    if (!req || !req.token || !req.token.sheetId) return { ok: false, error: "Missing token.sheetId" };
    if (!req.mapping) return { ok: false, error: "Missing mapping" };

    const sheetId = String(req.token.sheetId);

    const { warnings, items, resolved } = readMappedRows_(sheetId, req.mapping);

    const outRows = items.map(({ mpn, qtyVal }) => {
      const out = new Array(MOUSER_HEADERS.length).fill("");
      out[0] = mpn;     // "Mfr Part Number (Input)"
      out[5] = qtyVal;  // "Quantity 1"
      return out;
    });

    const outSS = SpreadsheetApp.create(
      `Mouser_BOM_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd_HHmmss")}`
    );
    const sheet1 = outSS.getSheets()[0];
    sheet1.setName("Sheet1");

    sheet1.getRange(1, 1, 1, MOUSER_HEADERS.length).setValues([MOUSER_HEADERS]);
    sheet1.getRange(2, 1, outRows.length, MOUSER_HEADERS.length).setValues(outRows);

    // Mouser template usually has 3 sheets in their sample
    outSS.insertSheet("Sheet2");
    outSS.insertSheet("Sheet3");

    SpreadsheetApp.flush();
    Utilities.sleep(800);

    const exp = exportGoogleFileAsXlsxBlob_(outSS.getId(), "mouser_bom.xlsx");
    if (!exp.ok) return { ok: false, error: exp.error };

    const b64 = Utilities.base64Encode(exp.blob.getBytes());
    const dataUrl = `data:${exp.mimeType};base64,${b64}`;

    return {
      ok: true,
      itemsCount: items.length,
      warnings,
      resolved,
      download: {
        filename: "mouser_bom.xlsx",
        mimeType: exp.mimeType,
        dataUrl
      }
    };
  } catch (err) {
    return { ok: false, error: String(err) };
  }
}

/**
 * Convert to Digi-Key template (.xlsx)
 * Requirements:
 *  - Header must be on row 2
 *  - Column A header: "Manufacturer Product Number"
 *  - Column B header: "Quantity"
 */
function convertToDigiKeyTemplate(req) {
  try {
    if (!req || !req.token || !req.token.sheetId) return { ok: false, error: "Missing token.sheetId" };
    if (!req.mapping) return { ok: false, error: "Missing mapping" };

    const sheetId = String(req.token.sheetId);

    const { warnings, items, resolved } = readMappedRows_(sheetId, req.mapping);

    const outRows = items.map(({ mpn, qtyVal }) => [mpn, qtyVal]);

    const outSS = SpreadsheetApp.create(
      `DigiKey_BOM_${Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyyMMdd_HHmmss")}`
    );
    const sh = outSS.getSheets()[0];
    sh.setName("Sheet1");

    // Row 1 blank by design
    sh.getRange(2, 1, 1, DIGIKEY_HEADERS.length).setValues([DIGIKEY_HEADERS]);
    sh.getRange(3, 1, outRows.length, DIGIKEY_HEADERS.length).setValues(outRows);

    SpreadsheetApp.flush();
    Utilities.sleep(800);

    const exp = exportGoogleFileAsXlsxBlob_(outSS.getId(), "digikey_bom.xlsx");
    if (!exp.ok) return { ok: false, error: exp.error };

    const b64 = Utilities.base64Encode(exp.blob.getBytes());
    const dataUrl = `data:${exp.mimeType};base64,${b64}`;

    return {
      ok: true,
      itemsCount: items.length,
      warnings,
      resolved,
      download: {
        filename: "digikey_bom.xlsx",
        mimeType: exp.mimeType,
        dataUrl
      }
    };
  } catch (err) {
    return { ok: false, error: String(err) };
  }
}
